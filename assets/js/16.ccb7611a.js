(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{361:function(e,s,t){"use strict";t.r(s);var o=t(42),r=Object(o.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"node-js篇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-js篇"}},[e._v("#")]),e._v(" Node.js篇")]),e._v(" "),t("ul",[t("li",[e._v("Node.js 是一个开源与跨平台的 JavaScript 运行时环境。 它是一个可用于几乎任何项目的流行工具！")]),e._v(" "),t("li",[e._v("Node.js 在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核）。 这使 Node.js 表现得非常出色。")]),e._v(" "),t("li",[e._v("Node.js 应用程序运行于单个线程中，无需为每个请求创建新的线程。")]),e._v(" "),t("li",[e._v("Node.js 在其标准库中提供了一组异步的 I/O 原生功能（用以防止 JavaScript 代码被阻塞），并且 Node.js 中-的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。")]),e._v(" "),t("li",[e._v("Node.js 执行 I/O 操作时（例如从网络读取、访问数据库或文件系统），Node.js 会在响应返回时恢复操作，而不是阻塞线程并浪费 CPU 循环等待。这使 Node.js 可以在一台服务器上处理数千个并发连接，而无需引入管理线程并发的负担（这可能是重大 bug 的来-源）。")]),e._v(" "),t("li",[e._v("在 Node.js 中，可以毫无问题地使用新的 ECMAScript 标准，因为不必等待所有用户更新其浏览器，你可以通过更改 Node.js 版本来决定要使用的 ECMAScript 版本，并且还可以通过运行带有标志的 Node.js 来启用特定的实验中的特性。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);