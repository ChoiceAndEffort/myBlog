(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{366:function(e,t,a){"use strict";a.r(t);var r=a(42),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"vuex虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex虚拟dom"}},[e._v("#")]),e._v(" Vuex虚拟DOM")]),e._v(" "),a("h2",{attrs:{id:"真实dom和其解析流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#真实dom和其解析流程"}},[e._v("#")]),e._v(" 真实DOM和其解析流程")]),e._v(" "),a("blockquote",[a("p",[e._v("浏览器渲染引擎工作流程都差不多，大致分为5步，创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting")])]),e._v(" "),a("ul",[a("li",[e._v("第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。")]),e._v(" "),a("li",[e._v("第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。")]),e._v(" "),a("li",[e._v("第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。")]),e._v(" "),a("li",[e._v("第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。")]),e._v(" "),a("li",[e._v("第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。")])]),e._v(" "),a("h2",{attrs:{id:"为啥会有vue虚拟dom-js操作真实dom的代价！"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为啥会有vue虚拟dom-js操作真实dom的代价！"}},[e._v("#")]),e._v(" 为啥会有Vue虚拟DOM, JS操作真实DOM的代价！")]),e._v(" "),a("blockquote",[a("p",[e._v("用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。")])]),e._v(" "),a("h2",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[e._v("#")]),e._v(" 虚拟DOM")]),e._v(" "),a("ul",[a("li",[e._v("Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，")]),e._v(" "),a("li",[e._v("虚拟DOM就是为了解决浏览器性能问题而被设计出来的。")]),e._v(" "),a("li",[e._v("虚拟DOM是通过JS语法模拟DOM创建的JS对象放在内存中,")]),e._v(" "),a("li",[e._v("操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。")])]),e._v(" "),a("h2",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[e._v("#")]),e._v(" Diff算法")]),e._v(" "),a("blockquote",[a("p",[e._v("真实DOM树和虚拟DOM树,  两棵树如果完全比较时间复杂度是O(n^3),要实现这么低的时间复杂度，意味着只能平层的比较两棵树的节点，> 放弃了深度遍历。这样做，似乎牺牲掉了一定的精确性来换取速度，但考虑到现实中前端页面通常也不会跨层移动DOM元素，这样做是最优的。\n在实际代码中，会对新旧两棵树进行一个深度的遍历，每个节点都会有一个标记。每遍历到一个节点就把该节点和新的树进行对比，如果有差异就记录到一个对象中。\n平层Diff比较，只有以下4种情况：\n1、节点类型变了\n2、节点类型一样，仅仅属性或属性值变了\n3、文本变了，\n4、移动／增加／删除 子节点，")])]),e._v(" "),a("ul",[a("li",[e._v("Diff算法只是为了虚拟DOM和真实DOM更高效的比较替换.")])]),e._v(" "),a("h2",{attrs:{id:"遍历的时候为啥要使用key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#遍历的时候为啥要使用key"}},[e._v("#")]),e._v(" 遍历的时候为啥要使用Key")]),e._v(" "),a("ul",[a("li",[e._v("https://www.cnblogs.com/wuqun/p/13201558.html")])]),e._v(" "),a("blockquote"),e._v(" "),a("p",[e._v("在DOM节点的遍历的 时候,如果新增,删除,移动DOM节点,如果不增加Key的话,会按照修改后虚拟DOM节点就重新遍历,对于那些没有变动的DOM节点会重新卸载,然后装载到新的位置,渲染比较损耗性能,如果增加key以后,虚拟DOM会识别这个节点的key没有变动,然后不去重新熏染,只对更改的节点进行渲染,这样性能会比较好.")])])}),[],!1,null,null,null);t.default=v.exports}}]);